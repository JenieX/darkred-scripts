"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const format_1 = require("../format");
const rules_util_1 = require("../rules-util");
const ast_util_1 = require("../ast-util");
const char_util_1 = require("../char-util");
const EMPTY_UTF16 = {
    chars: char_util_1.emptyCharSet({}),
    complete: false,
};
const EMPTY_UNICODE = {
    chars: char_util_1.emptyCharSet({ unicode: true }),
    complete: false,
};
function createChars(element, flags) {
    function empty() {
        return flags.unicode ? EMPTY_UNICODE : EMPTY_UTF16;
    }
    switch (element.type) {
        case "Character":
        case "CharacterSet":
            return {
                chars: char_util_1.toCharSet(element, flags),
                complete: true,
            };
        case "CharacterClass":
            return {
                chars: char_util_1.toCharSet(element, flags),
                complete: true,
            };
        case "Group":
        case "CapturingGroup": {
            const results = element.alternatives.map(a => {
                if (a.elements.length === 1) {
                    return createChars(a.elements[0], flags);
                }
                else {
                    return empty();
                }
            });
            const union = empty().chars.union(...results.map(({ chars }) => chars));
            return {
                chars: union,
                complete: results.every(({ complete }) => complete),
            };
        }
        default:
            return empty();
    }
}
function quantize(element, quant) {
    if (quant.min === 0 && quant.max === 0) {
        if (ast_util_1.hasSomeDescendant(element, d => d.type === "CapturingGroup")) {
            return element.raw + "{0}";
        }
        else {
            return "";
        }
    }
    if (quant.min === 1 && quant.max === 1) {
        return element.raw;
    }
    return element.raw + ast_util_1.quantToString(quant);
}
function short(str) {
    return format_1.shorten(str, 20, "center");
}
function isGroupOrCharacter(element) {
    switch (element.type) {
        case "Group":
        case "CapturingGroup":
        case "Character":
        case "CharacterClass":
        case "CharacterSet":
            return true;
        default:
            return false;
    }
}
function getReplacement(current, next, flags) {
    if (current.type === "Quantifier" &&
        current.min !== current.max &&
        next.type === "Quantifier" &&
        next.min !== next.max &&
        next.greedy === current.greedy &&
        (current.max === Infinity || next.max === Infinity)) {
        const currChars = createChars(current.element, flags);
        const nextChars = createChars(next.element, flags);
        const greedy = current.greedy;
        let currQuant, nextQuant;
        if (next.max === Infinity && currChars.complete && nextChars.chars.isSupersetOf(currChars.chars)) {
            currQuant = {
                min: current.min,
                max: current.min,
                greedy,
            };
            nextQuant = next;
        }
        else if (current.max === Infinity && nextChars.complete && currChars.chars.isSupersetOf(nextChars.chars)) {
            currQuant = current;
            nextQuant = {
                min: next.min,
                max: next.min,
                greedy,
            };
        }
        else {
            return null;
        }
        const raw = quantize(current.element, currQuant) + quantize(next.element, nextQuant);
        let message;
        if (currQuant.max === 0 && next.max === nextQuant.max && next.min === nextQuant.min) {
            message = `${short(format_1.mention(current))} can be removed because it is a subset of ${short(format_1.mention(next))}.`;
        }
        else if (nextQuant.max === 0 && current.max === currQuant.max && current.min === currQuant.min) {
            message = `${short(format_1.mention(next))} can be removed because it is a subset of ${short(format_1.mention(current))}.`;
        }
        else {
            message = `They should be replaced with ${format_1.mention(raw)}.`;
        }
        if (current.max === Infinity && next.max === Infinity) {
            message += " They might cause excessive backtracking otherwise.";
        }
        return { raw, message };
    }
    else if (current.type === "Quantifier" && isGroupOrCharacter(next)) {
        const currChars = createChars(current.element, flags);
        const nextChars = createChars(next, flags);
        if (currChars.complete && nextChars.complete && currChars.chars.equals(nextChars.chars)) {
            const raw = current.element.raw + ast_util_1.quantToString(ast_util_1.quantAdd(current, 1));
            return {
                message: `${short(format_1.mention(next))} can be combined with ${short(format_1.mention(current))}.`,
                raw,
            };
        }
        else {
            return null;
        }
    }
    else if (isGroupOrCharacter(current) && next.type === "Quantifier") {
        const currChars = createChars(current, flags);
        const nextChars = createChars(next.element, flags);
        if (next.min === 0 && next.max === 1) {
            return null;
        }
        if (currChars.complete && nextChars.complete && currChars.chars.equals(nextChars.chars)) {
            const raw = next.element.raw + ast_util_1.quantToString(ast_util_1.quantAdd(next, 1));
            return {
                message: `${short(format_1.mention(current))} can be combined with ${short(format_1.mention(next))}.`,
                raw,
            };
        }
        else {
            return null;
        }
    }
    else {
        return null;
    }
}
exports.default = {
    meta: {
        type: "suggestion",
        docs: {
            description: "Use optimal quantifiers for concatenated quantified characters.",
            url: rules_util_1.getDocUrl("optimal-concatenation-quantifier"),
        },
        fixable: "code",
        schema: [
            {
                type: "object",
                properties: {
                    fixable: {
                        type: "boolean",
                    },
                },
                additionalProperties: false,
            },
        ],
    },
    create(context) {
        const options = context.options[0] || {};
        const fixable = options.fixable != undefined ? options.fixable : true;
        return rules_util_1.createRuleListener(({ visitAST, flags, replaceElement, reportElements }) => {
            visitAST({
                onAlternativeEnter(node) {
                    for (let i = 0; i < node.elements.length - 1; i++) {
                        const current = node.elements[i];
                        const next = node.elements[i + 1];
                        const replacement = getReplacement(current, next, flags);
                        if (replacement) {
                            let message = `The quantifiers of ${format_1.mention(short(current.raw))} and ${format_1.mention(short(next.raw))} are not optimal. ` + replacement.message;
                            const involvesCapturingGroup = ast_util_1.hasCapturingGroup(current) || ast_util_1.hasCapturingGroup(next);
                            if (fixable && !involvesCapturingGroup) {
                                const before = node.raw.substr(0, current.start - node.start);
                                const after = node.raw.substr(next.end - node.start, node.end - next.end);
                                context.report(Object.assign(Object.assign({ message }, replaceElement(node, before + replacement.raw + after)), reportElements([current, next])));
                            }
                            else {
                                if (involvesCapturingGroup) {
                                    message +=
                                        " This cannot be fixed automatically because it might change a capturing group.";
                                }
                                context.report(Object.assign({ message }, reportElements([current, next])));
                            }
                        }
                    }
                },
            });
        });
    },
};
