"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const format_1 = require("../format");
const rules_util_1 = require("../rules-util");
const ast_util_1 = require("../ast-util");
function getCombinedQuant(node, nested) {
    if (node.max === 0 || nested.max === 0) {
        return null;
    }
    else if (node.greedy === nested.greedy) {
        const greedy = node.greedy;
        const a = nested.min;
        const b = nested.max;
        const c = node.min;
        const d = node.max;
        const condition = b === Infinity && c === 0 ? a <= 1 : c === d || b * c + 1 >= a * (c + 1);
        if (condition) {
            return {
                min: a * c,
                max: b * d,
                greedy,
            };
        }
        else {
            return null;
        }
    }
    else {
        return null;
    }
}
function getSimplifiedChildQuant(parent, child) {
    if (parent.max === 0 || child.max === 0) {
        return null;
    }
    else if (parent.greedy !== child.greedy) {
        return null;
    }
    else {
        let min = child.min;
        let max = child.max;
        if (min === 0 && parent.min === 0) {
            min = 1;
        }
        if (parent.max === Infinity && (min === 0 || min === 1) && max > 1) {
            max = 1;
        }
        return { min, max, greedy: child.greedy };
    }
}
exports.default = {
    meta: {
        type: "suggestion",
        docs: {
            description: "Disallow nested quantifiers that can be rewritten as one quantifier.",
            url: rules_util_1.getDocUrl("no-trivially-nested-quantifier"),
        },
        fixable: "code",
    },
    create(context) {
        return rules_util_1.createRuleListener(({ visitAST, replaceElement }) => {
            const ignore = new Set();
            visitAST({
                onQuantifierEnter(node) {
                    if (ast_util_1.hasSomeAncestor(node, a => ignore.has(a))) {
                        return;
                    }
                    if (node.max === 0) {
                        ignore.add(node);
                        return;
                    }
                    const element = node.element;
                    if (element.type === "Group" &&
                        element.alternatives.length === 1 &&
                        element.alternatives[0].elements.length === 1) {
                        const nested = element.alternatives[0].elements[0];
                        if (nested.type === "Quantifier") {
                            const newQuant = getCombinedQuant(node, nested);
                            if (newQuant) {
                                const quantStr = ast_util_1.quantToString(newQuant);
                                const replacement = nested.element.raw + quantStr;
                                const messagePreview = format_1.shorten(nested.element.raw, 20, "end") + quantStr;
                                ignore.add(node);
                                context.report(Object.assign({ message: `The nested quantifiers can be rewritten as ${format_1.mention(messagePreview)}.` }, replaceElement(node, replacement)));
                                return;
                            }
                        }
                    }
                    if (element.type === "Group" || element.type === "CapturingGroup") {
                        for (const alternative of element.alternatives) {
                            const nested = alternative.elements[0];
                            if (!(alternative.elements.length === 1 && nested.type === "Quantifier")) {
                                continue;
                            }
                            const newQuant = getSimplifiedChildQuant(node, nested);
                            if (!newQuant || (newQuant.min === nested.min && newQuant.max === nested.max)) {
                                continue;
                            }
                            ignore.add(node);
                            if (newQuant.min === 1 && newQuant.max === 1) {
                                const replacement = nested.element.raw;
                                context.report(Object.assign({ message: "The nested quantifier is unnecessary and can be replaced with its element." }, replaceElement(nested, replacement, { dependsOn: node })));
                            }
                            else {
                                const quantStr = ast_util_1.quantToString(newQuant);
                                const replacement = nested.element.raw + quantStr;
                                const messagePreview = format_1.shorten(nested.element.raw, 20, "end") + quantStr;
                                ignore.add(node);
                                context.report(Object.assign({ message: `The nested quantifiers can be rewritten as ${format_1.mention(messagePreview)}.` }, replaceElement(nested, replacement, { dependsOn: node })));
                            }
                        }
                    }
                },
            });
        });
    },
};
