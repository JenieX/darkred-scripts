"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const format_1 = require("../format");
const rules_util_1 = require("../rules-util");
const char_util_1 = require("../char-util");
exports.default = {
    meta: {
        type: "suggestion",
        docs: {
            description: "Disallows unnecessary elements in character classes.",
            url: rules_util_1.getDocUrl("optimized-character-class"),
        },
        fixable: "code",
    },
    create(context) {
        return rules_util_1.createRuleListener(({ visitAST, flags, removeElement, replaceElement }) => {
            visitAST({
                onCharacterClassEnter(node) {
                    const elements = node.elements;
                    if (elements.length === 0) {
                        return;
                    }
                    const reports = new Map();
                    function checkRangeElements(range) {
                        if (range.min.value === range.max.value) {
                            reports.set(range, {
                                message: `${format_1.mentionCharElement(range)} contains only a single value.`,
                                replacement: range.min.raw === "-" ? "\\-" : range.min.raw,
                            });
                        }
                        if (range.min.value + 1 === range.max.value) {
                            const min = range.min.raw === "-" ? "\\-" : range.min.raw;
                            const max = range.max.raw === "-" ? "\\-" : range.max.raw;
                            reports.set(range, {
                                message: `${format_1.mentionCharElement(range)} contains only its two ends.`,
                                replacement: min + max,
                            });
                        }
                    }
                    for (const element of elements) {
                        if (element.type === "CharacterClassRange") {
                            checkRangeElements(element);
                        }
                    }
                    const empty = char_util_1.emptyCharSet(flags);
                    const elementChars = elements.map(e => char_util_1.toCharSet([e], flags));
                    const order = ["Character", "CharacterClassRange", "CharacterSet"];
                    for (const currentType of order) {
                        for (let i = elements.length - 1; i >= 0; i--) {
                            const current = elements[i];
                            if (current.type !== currentType) {
                                continue;
                            }
                            const currentChars = elementChars[i];
                            const totalWithCurrent = empty.union(...elementChars.filter((_, index) => index !== i));
                            if (totalWithCurrent.isSupersetOf(currentChars)) {
                                elementChars[i] = empty;
                                let simpleSuper = undefined;
                                for (let k = 0; k < elements.length; k++) {
                                    if (elementChars[k].isSupersetOf(currentChars)) {
                                        simpleSuper = elements[k];
                                        break;
                                    }
                                }
                                if (simpleSuper === undefined) {
                                    reports.set(current, {
                                        message: `${format_1.mentionCharElement(current)} is already included by some combination of other elements.`,
                                        replacement: "",
                                    });
                                }
                                else {
                                    reports.set(current, {
                                        message: `${format_1.mentionCharElement(current)} is already included by ${format_1.mentionCharElement(simpleSuper)}.`,
                                        replacement: "",
                                    });
                                }
                            }
                        }
                    }
                    for (const [element, { message, replacement }] of reports) {
                        if (replacement) {
                            context.report(Object.assign({ message }, replaceElement(element, replacement, {
                                dependsOnFlags: true,
                            })));
                        }
                        else {
                            context.report(Object.assign({ message }, removeElement(element, {
                                dependsOnFlags: true,
                            })));
                        }
                    }
                },
            });
        });
    },
};
