"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const rules_util_1 = require("../rules-util");
const format_1 = require("../format");
const refa_1 = require("refa");
const ast_util_1 = require("../ast-util");
const util_1 = require("../util");
const char_util_1 = require("../char-util");
exports.default = {
    meta: {
        type: "problem",
        docs: {
            description: "Disallow assertions that are known to always accept (or reject).",
            url: rules_util_1.getDocUrl("no-unnecessary-assertions"),
        },
    },
    create(context) {
        return rules_util_1.createRuleListener(({ visitAST, flags, reportElement }) => {
            function checkStartOrEnd(node) {
                const direction = ast_util_1.assertionKindToMatchingDirection(node.kind);
                const next = ast_util_1.getFirstCharAfter(node, direction, flags);
                const followed = node.kind === "end" ? "followed" : "preceded";
                if (!next.char.edge) {
                    if (!flags.multiline) {
                        context.report(Object.assign({ message: `${format_1.mention(node)} will always reject because it is ${followed} by a character.` }, reportElement(node)));
                    }
                    else {
                        const oldDotAll = flags.dotAll;
                        flags.dotAll = false;
                        const dot = refa_1.JS.createCharSet([{ kind: "any" }], flags);
                        flags.dotAll = oldDotAll;
                        if (next.char.char.isSubsetOf(dot)) {
                            context.report(Object.assign({ message: `${format_1.mention(node)} will always reject because it is ${followed} by a non-line-terminator character.` }, reportElement(node)));
                        }
                        else if (next.char.char.isDisjointWith(dot)) {
                            context.report(Object.assign({ message: `${format_1.mention(node)} will always accept because it is ${followed} by a line-terminator character.` }, reportElement(node)));
                        }
                    }
                }
            }
            function checkWordBoundary(node) {
                const word = char_util_1.wordCharSet(flags);
                const next = ast_util_1.getFirstCharAfter(node, "ltr", flags);
                const prev = ast_util_1.getFirstCharAfter(node, "rtl", flags);
                if (prev.char.edge || next.char.edge) {
                    return;
                }
                const nextIsWord = next.char.char.isSubsetOf(word);
                const prevIsWord = prev.char.char.isSubsetOf(word);
                const nextIsNonWord = next.char.char.isDisjointWith(word);
                const prevIsNonWord = prev.char.char.isDisjointWith(word);
                const accept = node.negate ? "reject" : "accept";
                const reject = node.negate ? "accept" : "reject";
                if (prevIsNonWord) {
                    if (nextIsWord) {
                        context.report(Object.assign({ message: `${format_1.mention(node)} will always ${accept} because it is preceded by a non-word character and followed by a word character.` }, reportElement(node)));
                    }
                    if (nextIsNonWord) {
                        context.report(Object.assign({ message: `${format_1.mention(node)} will always ${reject} because it is preceded by a non-word character and followed by a non-word character.` }, reportElement(node)));
                    }
                }
                if (prevIsWord) {
                    if (nextIsNonWord) {
                        context.report(Object.assign({ message: `${format_1.mention(node)} will always ${accept} because it is preceded by a word character and followed by a non-word character.` }, reportElement(node)));
                    }
                    if (nextIsWord) {
                        context.report(Object.assign({ message: `${format_1.mention(node)} will always ${reject} because it is preceded by a word character and followed by a word character.` }, reportElement(node)));
                    }
                }
            }
            function checkLookaround(node) {
                if (ast_util_1.isPotentiallyEmpty(node.alternatives)) {
                    return;
                }
                const direction = ast_util_1.assertionKindToMatchingDirection(node.kind);
                const after = ast_util_1.getFirstCharAfter(node, direction, flags);
                if (after.char.edge) {
                    return;
                }
                const firstOf = ast_util_1.getFirstCharConsumedBy(node.alternatives, direction, flags);
                if (firstOf.empty) {
                    return;
                }
                const accept = node.negate ? "reject" : "accept";
                const reject = node.negate ? "accept" : "reject";
                const nodeName = `${node.negate ? "negative " : ""}${node.kind} ${format_1.mention(node)}`;
                if (after.char.char.isDisjointWith(firstOf.char)) {
                    context.report(Object.assign({ message: `The ${nodeName} will always ${reject}.` }, reportElement(node)));
                }
                if (!ast_util_1.hasSomeDescendant(node, d => d !== node && d.type === "Assertion")) {
                    const range = ast_util_1.getLengthRange(node.alternatives);
                    if (range && range.max === 1) {
                        if (firstOf.exact && after.char.char.isSubsetOf(firstOf.char)) {
                            context.report(Object.assign({ message: `The ${nodeName} will always ${accept}.` }, reportElement(node)));
                        }
                    }
                }
            }
            visitAST({
                onAssertionEnter(node) {
                    switch (node.kind) {
                        case "start":
                        case "end":
                            checkStartOrEnd(node);
                            break;
                        case "word":
                            checkWordBoundary(node);
                            break;
                        case "lookahead":
                        case "lookbehind":
                            checkLookaround(node);
                            break;
                        default:
                            throw util_1.assertNever(node);
                    }
                },
            });
        });
    },
};
