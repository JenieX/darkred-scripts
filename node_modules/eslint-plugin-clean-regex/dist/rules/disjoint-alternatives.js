"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const refa_1 = require("refa");
const format_1 = require("../format");
const rules_util_1 = require("../rules-util");
const ast_util_1 = require("../ast-util");
const fa_util_1 = require("../fa-util");
exports.default = {
    meta: {
        type: "problem",
        docs: {
            description: "Disallow different alternatives that can match the same words.",
            url: rules_util_1.getDocUrl("disjoint-alternatives"),
        },
    },
    create(context) {
        return rules_util_1.createRuleListener(({ visitAST, flags, pattern, reportElement }) => {
            const parser = refa_1.JS.Parser.fromAst({ pattern, flags });
            function toNfa(alt) {
                try {
                    const result = parser.parseElement(alt, { backreferences: "disable", assertions: "disable" });
                    const nfa = refa_1.NFA.fromRegex(result.expression, { maxCharacter: result.maxCharacter });
                    nfa.withoutEmptyWord();
                    return nfa;
                }
                catch (e) {
                    if (e instanceof refa_1.TooManyNodesError) {
                        return refa_1.NFA.empty({ maxCharacter: flags.unicode ? 0x10ffff : 0xffff });
                    }
                    throw e;
                }
            }
            function findFirstSuperset(alternatives, subset) {
                for (const alt of alternatives) {
                    if (fa_util_1.nfaIsSupersetOf(toNfa(alt), subset)) {
                        return [alt];
                    }
                }
                return [];
            }
            function findNonDisjoint(alternatives, set) {
                return alternatives.filter(alt => {
                    return !areDisjoint(toNfa(alt), set);
                });
            }
            function areDisjoint(a, b) {
                return a.isDisjointWith(b, {
                    maxNodes: 1000,
                });
            }
            function checkAlternatives(alternatives) {
                if (alternatives.length < 2) {
                    return "disjoint";
                }
                let result = "disjoint";
                let total = undefined;
                for (const alt of alternatives) {
                    const isLast = alt === alternatives[alternatives.length - 1];
                    const nfa = toNfa(alt);
                    if (nfa.isEmpty) {
                    }
                    else if (!total) {
                        if (!isLast) {
                            total = nfa.copy();
                        }
                    }
                    else if (areDisjoint(total, nfa)) {
                        if (!isLast) {
                            total.union(nfa);
                        }
                    }
                    else {
                        const altIndex = alternatives.indexOf(alt);
                        const beforeAlternatives = alternatives.slice(0, altIndex);
                        const intersection = refa_1.NFA.fromIntersection(total, nfa);
                        const isSubset = fa_util_1.nfaEquals(nfa, intersection);
                        const cause = isSubset ? findFirstSuperset(beforeAlternatives, nfa) : [];
                        if (cause.length === 0) {
                            cause.push(...findNonDisjoint(beforeAlternatives, nfa));
                        }
                        const causeMsg = cause ? cause.map(format_1.mention).join(" | ") : "the previous one(s)";
                        const isSuperset = fa_util_1.nfaIsSupersetOf(nfa, fa_util_1.nfaUnionAll(cause.map(toNfa), nfa.options));
                        let message;
                        if (isSubset) {
                            message = isSuperset
                                ? `This alternative is the same as ${causeMsg} and can be removed.`
                                : `This alternative is a subset of ${causeMsg} and can be removed.`;
                            if (ast_util_1.hasSomeDescendant(alt, d => d.type === "CapturingGroup")) {
                                message += " This alternative contains a capturing group so be careful when removing.";
                            }
                        }
                        else {
                            let sharedLanguageMsg;
                            try {
                                sharedLanguageMsg = ` The shared language is ${format_1.toRegExpString(intersection)}.`;
                            }
                            catch (e) {
                                sharedLanguageMsg = "";
                            }
                            message = isSuperset
                                ? `This alternative is a superset of ${causeMsg}.`
                                : `This alternative is not disjoint with ${causeMsg}.${sharedLanguageMsg}`;
                        }
                        if (ast_util_1.underAStar(alt)) {
                            message += " This alternative is likely to cause exponential backtracking.";
                        }
                        context.report(Object.assign({ message }, reportElement(alt)));
                        result = "reported";
                    }
                }
                return result;
            }
            const ignoreNodes = new Set();
            function ignoreParents(node) {
                for (let parent = node.parent; parent; parent = parent.parent) {
                    ignoreNodes.add(parent);
                }
            }
            function process(node) {
                if (!ignoreNodes.has(node)) {
                    if (checkAlternatives(node.alternatives) === "reported") {
                        ignoreParents(node);
                    }
                }
            }
            visitAST({
                onAssertionLeave(node) {
                    if (node.kind === "lookahead" || node.kind === "lookbehind") {
                        process(node);
                    }
                },
                onCapturingGroupLeave: process,
                onGroupLeave: process,
                onPatternLeave: process,
            });
        });
    },
};
