"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const rules_util_1 = require("../rules-util");
const ast_util_1 = require("../ast-util");
const SPECIAL_CHARACTERS = new Set(".*+?|()[]{}^$/");
exports.default = {
    meta: {
        type: "suggestion",
        docs: {
            description: "Disallow unnecessary character classes.",
            url: rules_util_1.getDocUrl("no-unnecessary-character-class"),
        },
        fixable: "code",
        schema: [
            {
                type: "object",
                properties: {
                    avoidEscape: {
                        type: "boolean",
                    },
                },
                additionalProperties: false,
            },
        ],
    },
    create(context) {
        const avoidEscape = !!(context.options[0] || {}).avoidEscape;
        return rules_util_1.createRuleListener(({ visitAST, pattern, parseExpression, replaceElement }) => {
            visitAST({
                onCharacterClassEnter(node) {
                    if (node.elements.length !== 1) {
                        return;
                    }
                    const element = node.elements[0];
                    if (element.type === "CharacterSet") {
                        const set = node.negate ? ast_util_1.negateCharacterSetRaw(element) : element.raw;
                        context.report(Object.assign({ message: "Unnecessary character class." }, replaceElement(node, set)));
                    }
                    else if (element.type === "Character") {
                        if (node.negate) {
                            return;
                        }
                        if (element.value > 0 && ast_util_1.isOctalEscapeSequence(element)) {
                            return;
                        }
                        if (element.raw === "\\b") {
                            if (!avoidEscape) {
                                context.report(Object.assign({ message: "Unnecessary character class." }, replaceElement(node, "\\x08")));
                            }
                            return;
                        }
                        if (SPECIAL_CHARACTERS.has(element.raw)) {
                            if (!avoidEscape) {
                                context.report(Object.assign({ message: "Unnecessary character class." }, replaceElement(node, "\\" + element.raw)));
                            }
                            return;
                        }
                        if (ast_util_1.isEscapeSequence(element)) {
                            if (!avoidEscape) {
                                context.report(Object.assign({ message: "Unnecessary character class." }, replaceElement(node, element.raw)));
                            }
                            return;
                        }
                        if (/^\\[^kbBpP]$/.test(element.raw)) {
                            context.report(Object.assign({ message: "Unnecessary character class." }, replaceElement(node, element.raw)));
                            return;
                        }
                        const parent = node.parent;
                        const before = pattern.raw.substr(0, node.start - pattern.start);
                        const after = pattern.raw.substr(node.end - pattern.start);
                        const withoutCharacterClass = before + element.raw + after;
                        const ast = parseExpression(withoutCharacterClass);
                        if (ast) {
                            let equal;
                            if (parent.type === "Alternative") {
                                const parentIndex = parent.elements.indexOf(node);
                                const oldElements = parent.elements;
                                const newElements = [
                                    ...parent.elements.slice(0, parentIndex),
                                    element,
                                    ...parent.elements.slice(parentIndex + 1),
                                ];
                                parent.elements = newElements;
                                try {
                                    equal = ast_util_1.areEqual(pattern, ast);
                                }
                                finally {
                                    parent.elements = oldElements;
                                }
                            }
                            else {
                                parent.element = element;
                                try {
                                    equal = ast_util_1.areEqual(pattern, ast);
                                }
                                finally {
                                    parent.element = node;
                                }
                            }
                            if (equal) {
                                context.report(Object.assign({ message: "Unnecessary character class." }, replaceElement(node, element.raw)));
                            }
                        }
                    }
                },
            });
        });
    },
};
