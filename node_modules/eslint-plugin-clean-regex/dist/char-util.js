"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isMatchNone = exports.isMatchAll = exports.wordCharSet = exports.lineTerminatorCharSet = exports.allCharSet = exports.emptyCharSet = exports.toCharSet = void 0;
const refa_1 = require("refa");
const util_1 = require("./util");
function toCharSet(elements, flags) {
    if (Array.isArray(elements)) {
        return refa_1.JS.createCharSet(elements.map(e => {
            switch (e.type) {
                case "Character":
                    return e.value;
                case "CharacterClassRange":
                    return { min: e.min.value, max: e.max.value };
                case "CharacterSet":
                    return e;
                default:
                    throw util_1.assertNever(e);
            }
        }), flags);
    }
    else {
        switch (elements.type) {
            case "Character": {
                return refa_1.JS.createCharSet([elements.value], flags);
            }
            case "CharacterClass": {
                const chars = toCharSet(elements.elements, flags);
                if (elements.negate) {
                    return chars.negate();
                }
                return chars;
            }
            case "CharacterSet": {
                return refa_1.JS.createCharSet([elements], flags);
            }
            default:
                throw util_1.assertNever(elements);
        }
    }
}
exports.toCharSet = toCharSet;
const EMPTY_UTF16_CHARSET = refa_1.CharSet.empty(0xffff);
const EMPTY_UNICODE_CHARSET = refa_1.CharSet.empty(0x10ffff);
function emptyCharSet(flags) {
    if (flags.unicode) {
        return EMPTY_UNICODE_CHARSET;
    }
    else {
        return EMPTY_UTF16_CHARSET;
    }
}
exports.emptyCharSet = emptyCharSet;
const ALL_UTF16_CHARSET = refa_1.CharSet.all(0xffff);
const ALL_UNICODE_CHARSET = refa_1.CharSet.all(0x10ffff);
function allCharSet(flags) {
    if (flags.unicode) {
        return ALL_UNICODE_CHARSET;
    }
    else {
        return ALL_UTF16_CHARSET;
    }
}
exports.allCharSet = allCharSet;
const LINE_TERMINATOR_UTF16_CHARSET = refa_1.JS.createCharSet([{ kind: "any" }], { unicode: false }).negate();
const LINE_TERMINATOR_UNICODE_CHARSET = refa_1.JS.createCharSet([{ kind: "any" }], { unicode: true }).negate();
function lineTerminatorCharSet(flags) {
    if (flags.unicode) {
        return LINE_TERMINATOR_UNICODE_CHARSET;
    }
    else {
        return LINE_TERMINATOR_UTF16_CHARSET;
    }
}
exports.lineTerminatorCharSet = lineTerminatorCharSet;
const WORD_UTF16_CHARSET = refa_1.JS.createCharSet([{ kind: "word", negate: false }], { unicode: false });
const WORD_UNICODE_CHARSET = refa_1.JS.createCharSet([{ kind: "word", negate: false }], { unicode: true, ignoreCase: false });
const WORD_UNICODE_IGNORE_CASE_CHARSET = refa_1.JS.createCharSet([{ kind: "word", negate: false }], {
    unicode: true,
    ignoreCase: true,
});
function wordCharSet(flags) {
    if (flags.unicode) {
        if (flags.ignoreCase) {
            return WORD_UNICODE_IGNORE_CASE_CHARSET;
        }
        else {
            return WORD_UNICODE_CHARSET;
        }
    }
    else {
        return WORD_UTF16_CHARSET;
    }
}
exports.wordCharSet = wordCharSet;
function isMatchAll(char, flags) {
    if (char.type === "CharacterSet") {
        if (char.kind === "property") {
            return refa_1.JS.createCharSet([char], flags).isAll;
        }
        else if (char.kind === "any") {
            return !!flags.dotAll;
        }
        else {
            return false;
        }
    }
    else {
        if (char.negate && char.elements.length === 0) {
            return true;
        }
        else {
            if (char.negate) {
                return toCharSet(char.elements, flags).isEmpty;
            }
            else {
                return toCharSet(char.elements, flags).isAll;
            }
        }
    }
}
exports.isMatchAll = isMatchAll;
function isMatchNone(char, flags) {
    if (char.type === "CharacterSet") {
        if (char.kind === "property") {
            return refa_1.JS.createCharSet([char], flags).isEmpty;
        }
        else {
            return false;
        }
    }
    else {
        if (!char.negate && char.elements.length === 0) {
            return true;
        }
        else {
            if (char.negate) {
                return toCharSet(char.elements, flags).isAll;
            }
            else {
                return toCharSet(char.elements, flags).isEmpty;
            }
        }
    }
}
exports.isMatchNone = isMatchNone;
