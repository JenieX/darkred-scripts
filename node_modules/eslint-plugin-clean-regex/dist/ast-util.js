"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getParentPrefixAndSuffix = exports.underAStar = exports.effectiveQuantifierMax = exports.getSingleConsumedChar = exports.getFirstCharAfter = exports.getFirstConsumedCharAfter = exports.followPaths = exports.getFirstCharConsumedBy = exports.getLengthRange = exports.hasAssertionWithDirection = exports.assertionKindToMatchingDirection = exports.invertMatchingDirection = exports.matchingDirection = exports.getQuantifierRaw = exports.backreferenceAlwaysAfterGroup = exports.isEmptyBackreference = exports.elementsToCharacterClass = exports.negateCharacterSetRaw = exports.quantAdd = exports.quantToString = exports.nodeAt = exports.isEscapeSequence = exports.isHexadecimalEscapeSequence = exports.isControlEscapeSequence = exports.isOctalEscapeSequence = exports.minimalHexEscape = exports.getPattern = exports.getCapturingGroupNumber = exports.areEqual = exports.hasCapturingGroup = exports.hasSomeDescendant = exports.hasSomeAncestor = exports.isPotentiallyEmpty = exports.isEmpty = exports.isPotentiallyZeroLength = exports.isZeroLength = exports.getConstant = void 0;
const refa_1 = require("refa");
const regexpp_1 = require("regexpp");
const char_util_1 = require("./char-util");
const util_1 = require("./util");
function getConstant(node, flags) {
    switch (node.type) {
        case "Alternative": {
            let word = "";
            for (const element of node.elements) {
                const elementResult = getConstant(element, flags);
                if (elementResult === false) {
                    return false;
                }
                else {
                    word += elementResult.word;
                }
            }
            return { word };
        }
        case "Assertion":
        case "Flags": {
            return { word: "" };
        }
        case "Backreference": {
            if (isEmptyBackreference(node)) {
                return { word: "" };
            }
            else {
                return getConstant(node.resolved, flags);
            }
        }
        case "CapturingGroup":
        case "Group":
        case "Pattern": {
            if (node.alternatives.length == 0) {
                return { word: "" };
            }
            else if (node.alternatives.length == 1) {
                return getConstant(node.alternatives[0], flags);
            }
            else {
                let word = false;
                for (const alt of node.alternatives) {
                    const altResult = getConstant(alt, flags);
                    if (altResult === false) {
                        return false;
                    }
                    else if (word === false) {
                        word = altResult.word;
                    }
                    else if (word !== altResult.word) {
                        return false;
                    }
                }
                return word === false ? false : { word };
            }
        }
        case "Character": {
            const string = String.fromCodePoint(node.value);
            if (flags.ignoreCase && string.toLowerCase() !== string.toUpperCase()) {
                return false;
            }
            return { word: string };
        }
        case "CharacterClass": {
            if (node.negate) {
                return false;
            }
            let word = false;
            for (const element of node.elements) {
                const elementResult = getConstant(element, flags);
                if (elementResult === false) {
                    return false;
                }
                else if (word === false) {
                    word = elementResult.word;
                }
                else if (word !== elementResult.word) {
                    return false;
                }
            }
            return word === false ? false : { word };
        }
        case "CharacterClassRange": {
            return node.min.value == node.max.value && getConstant(node.min, flags);
        }
        case "CharacterSet": {
            return false;
        }
        case "Quantifier": {
            if (node.max === 0) {
                return { word: "" };
            }
            const elementResult = getConstant(node.element, flags);
            if (elementResult !== false) {
                if (elementResult.word === "") {
                    return elementResult;
                }
                else if (node.min === node.max) {
                    let word = "";
                    for (let i = node.min; i > 0; i--) {
                        word += elementResult.word;
                    }
                    return { word };
                }
            }
            return false;
        }
        case "RegExpLiteral": {
            return getConstant(node.pattern, flags);
        }
        default:
            return false;
    }
}
exports.getConstant = getConstant;
function isZeroLength(element) {
    if (Array.isArray(element)) {
        return element.every(a => isZeroLength(a));
    }
    switch (element.type) {
        case "Alternative":
            return element.elements.every(e => isZeroLength(e));
        case "Assertion":
            return true;
        case "Character":
        case "CharacterClass":
        case "CharacterSet":
            return false;
        case "Quantifier":
            return element.max === 0 || isZeroLength(element.element);
        case "Backreference":
            return isEmptyBackreference(element);
        case "CapturingGroup":
        case "Group":
            return isZeroLength(element.alternatives);
        default:
            throw util_1.assertNever(element);
    }
}
exports.isZeroLength = isZeroLength;
function isPotentiallyZeroLength(element) {
    if (Array.isArray(element)) {
        return element.some(a => isPotentiallyZeroLength(a));
    }
    switch (element.type) {
        case "Alternative":
            return element.elements.every(e => isPotentiallyZeroLength(e));
        case "Assertion":
            return true;
        case "Backreference":
            if (isEmptyBackreference(element)) {
                return true;
            }
            return isPotentiallyZeroLength(element.resolved);
        case "Character":
        case "CharacterClass":
        case "CharacterSet":
            return false;
        case "CapturingGroup":
        case "Group":
            return isPotentiallyZeroLength(element.alternatives);
        case "Quantifier":
            return element.min === 0 || isPotentiallyZeroLength(element.element);
        default:
            throw util_1.assertNever(element);
    }
}
exports.isPotentiallyZeroLength = isPotentiallyZeroLength;
function isEmpty(element) {
    if (Array.isArray(element)) {
        return element.every(isEmpty);
    }
    switch (element.type) {
        case "Alternative":
            return element.elements.every(isEmpty);
        case "Assertion":
            if (element.kind === "lookahead" || element.kind === "lookbehind") {
                if (!element.negate && isPotentiallyEmpty(element.alternatives)) {
                    return true;
                }
            }
            return false;
        case "Backreference":
            if (isEmptyBackreference(element)) {
                return true;
            }
            return isEmpty(element.resolved);
        case "Character":
        case "CharacterClass":
        case "CharacterSet":
            return false;
        case "CapturingGroup":
        case "Group":
            return isEmpty(element.alternatives);
        case "Quantifier":
            return element.max === 0 || isEmpty(element.element);
        default:
            throw util_1.assertNever(element);
    }
}
exports.isEmpty = isEmpty;
function isPotentiallyEmpty(element, options = {}) {
    if (Array.isArray(element)) {
        return element.some(a => isPotentiallyEmpty(a, options));
    }
    switch (element.type) {
        case "Alternative":
            return element.elements.every(e => isPotentiallyEmpty(e, options));
        case "Assertion":
            if (element.kind === "lookahead" || element.kind === "lookbehind") {
                if (!element.negate && isPotentiallyEmpty(element.alternatives, options)) {
                    return true;
                }
            }
            return false;
        case "Backreference":
            if (isEmptyBackreference(element)) {
                return true;
            }
            if (options.backreferencesAreNonEmpty) {
                return false;
            }
            else {
                return !backreferenceAlwaysAfterGroup(element) || isPotentiallyEmpty(element.resolved, options);
            }
        case "Character":
        case "CharacterClass":
        case "CharacterSet":
            return false;
        case "CapturingGroup":
        case "Group":
            return isPotentiallyEmpty(element.alternatives, options);
        case "Quantifier":
            return element.min === 0 || isPotentiallyEmpty(element.element, options);
        default:
            throw util_1.assertNever(element);
    }
}
exports.isPotentiallyEmpty = isPotentiallyEmpty;
function hasSomeAncestor(node, conditionFn) {
    let parent = node.parent;
    while (parent) {
        if (conditionFn(parent)) {
            return true;
        }
        parent = parent.parent;
    }
    return false;
}
exports.hasSomeAncestor = hasSomeAncestor;
function hasSomeDescendant(node, conditionFn, descentConditionFn) {
    if (conditionFn(node)) {
        return true;
    }
    if (descentConditionFn && !descentConditionFn(node)) {
        return false;
    }
    switch (node.type) {
        case "Alternative":
            return node.elements.some(e => hasSomeDescendant(e, conditionFn, descentConditionFn));
        case "Assertion":
            if (node.kind === "lookahead" || node.kind === "lookbehind") {
                return node.alternatives.some(a => hasSomeDescendant(a, conditionFn, descentConditionFn));
            }
            return false;
        case "CapturingGroup":
        case "Group":
        case "Pattern":
            return node.alternatives.some(a => hasSomeDescendant(a, conditionFn, descentConditionFn));
        case "CharacterClass":
            return node.elements.some(e => hasSomeDescendant(e, conditionFn, descentConditionFn));
        case "CharacterClassRange":
            return (hasSomeDescendant(node.min, conditionFn, descentConditionFn) ||
                hasSomeDescendant(node.max, conditionFn, descentConditionFn));
        case "Quantifier":
            return hasSomeDescendant(node.element, conditionFn, descentConditionFn);
        case "RegExpLiteral":
            return (hasSomeDescendant(node.pattern, conditionFn, descentConditionFn) ||
                hasSomeDescendant(node.flags, conditionFn, descentConditionFn));
    }
    return false;
}
exports.hasSomeDescendant = hasSomeDescendant;
function hasCapturingGroup(node) {
    return hasSomeDescendant(node, d => d.type === "CapturingGroup");
}
exports.hasCapturingGroup = hasCapturingGroup;
function areEqual(x, y) {
    if (x == y) {
        return true;
    }
    if (!x || !y || x.type != y.type) {
        return false;
    }
    function manyAreEqual(a, b) {
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0; i < a.length; i++) {
            if (!areEqual(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    function alternativesAreEqual(a, b) {
        return manyAreEqual(a.alternatives, b.alternatives);
    }
    switch (x.type) {
        case "Alternative": {
            const other = y;
            return manyAreEqual(x.elements, other.elements);
        }
        case "Assertion": {
            const other = y;
            if (x.kind === other.kind) {
                if (x.kind === "lookahead" || x.kind === "lookbehind") {
                    const otherLookaround = y;
                    return x.negate === otherLookaround.negate && alternativesAreEqual(x, otherLookaround);
                }
                else {
                    return x.raw === other.raw;
                }
            }
            return false;
        }
        case "Backreference": {
            const other = y;
            return areEqual(x.resolved, other.resolved);
        }
        case "CapturingGroup": {
            const other = y;
            const p1 = getPattern(x);
            const p2 = getPattern(other);
            if (p1 && p2) {
                const n1 = getCapturingGroupNumber(p1, x);
                const n2 = getCapturingGroupNumber(p2, other);
                if (n1 && n2) {
                    return n1 === n2 && alternativesAreEqual(x, other);
                }
            }
            return false;
        }
        case "Character": {
            const other = y;
            return x.value === other.value;
        }
        case "CharacterClass": {
            const other = y;
            return x.negate === other.negate && manyAreEqual(x.elements, other.elements);
        }
        case "CharacterClassRange": {
            const other = y;
            return areEqual(x.min, other.min) && areEqual(x.max, other.max);
        }
        case "CharacterSet": {
            const other = y;
            if (x.kind === "property" && other.kind === "property") {
                return x.negate === other.negate && x.key === other.key;
            }
            else {
                return x.raw === other.raw;
            }
        }
        case "Flags": {
            const other = y;
            return (x.dotAll === other.dotAll &&
                x.global === other.global &&
                x.ignoreCase === other.ignoreCase &&
                x.multiline === other.multiline &&
                x.sticky === other.sticky &&
                x.unicode === other.unicode);
        }
        case "Group":
        case "Pattern": {
            const other = y;
            return alternativesAreEqual(x, other);
        }
        case "Quantifier": {
            const other = y;
            return (x.min === other.min &&
                x.max === other.max &&
                x.greedy === other.greedy &&
                areEqual(x.element, other.element));
        }
        case "RegExpLiteral": {
            const other = y;
            return areEqual(x.flags, other.flags) && areEqual(x.pattern, other.pattern);
        }
        default:
            throw util_1.assertNever(x);
    }
}
exports.areEqual = areEqual;
function getCapturingGroupNumber(pattern, group) {
    let found = 0;
    try {
        regexpp_1.visitRegExpAST(pattern, {
            onCapturingGroupEnter(node) {
                found++;
                if (node === group) {
                    throw new Error();
                }
            },
        });
        return null;
    }
    catch (error) {
        return found;
    }
}
exports.getCapturingGroupNumber = getCapturingGroupNumber;
function getPattern(node) {
    switch (node.type) {
        case "Pattern":
            return node;
        case "RegExpLiteral":
            return node.pattern;
        case "Flags":
            return node.parent ? node.parent.pattern : null;
        default:
            return getPattern(node.parent);
    }
}
exports.getPattern = getPattern;
function minimalHexEscape(codePoint) {
    if (codePoint <= 0xff) {
        return "\\x" + codePoint.toString(16).padStart(2, "0");
    }
    else if (codePoint <= 0xffff) {
        return "\\u" + codePoint.toString(16).padStart(4, "0");
    }
    else {
        return "\\u{" + codePoint.toString(16) + "}";
    }
}
exports.minimalHexEscape = minimalHexEscape;
function isOctalEscapeSequence(node) {
    return /^\\[0-7]+$/.test(node.raw);
}
exports.isOctalEscapeSequence = isOctalEscapeSequence;
function isControlEscapeSequence(node) {
    return /^\\c[A-Za-z]$/.test(node.raw);
}
exports.isControlEscapeSequence = isControlEscapeSequence;
function isHexadecimalEscapeSequence(node) {
    return /^\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\})$/.test(node.raw);
}
exports.isHexadecimalEscapeSequence = isHexadecimalEscapeSequence;
function isEscapeSequence(node) {
    return (isOctalEscapeSequence(node) ||
        isHexadecimalEscapeSequence(node) ||
        isControlEscapeSequence(node) ||
        /^\\[fnrtv]$/.test(node.raw));
}
exports.isEscapeSequence = isEscapeSequence;
function nodeAt(root, index) {
    if (index < root.start || root.end >= index) {
        return undefined;
    }
    if (root.start == index) {
        return root;
    }
    switch (root.type) {
        case "Assertion":
        case "CapturingGroup":
        case "Group":
        case "Pattern":
            if (root.type === "Assertion" && !(root.kind === "lookahead" || root.kind === "lookbehind")) {
                break;
            }
            for (const alt of root.alternatives) {
                if (alt.end >= index) {
                    break;
                }
                const result = nodeAt(alt, index);
                if (result) {
                    return result;
                }
            }
            break;
        case "Quantifier": {
            const res = nodeAt(root.element, index);
            if (res) {
                return res;
            }
            break;
        }
        case "RegExpLiteral": {
            let res = nodeAt(root.flags, index);
            if (res) {
                return res;
            }
            res = nodeAt(root.pattern, index);
            if (res) {
                return res;
            }
            break;
        }
        default:
            break;
    }
    return root;
}
exports.nodeAt = nodeAt;
function quantToString(quant) {
    if (quant.max < quant.min ||
        quant.min < 0 ||
        !Number.isInteger(quant.min) ||
        !(Number.isInteger(quant.max) || quant.max === Infinity)) {
        throw new Error(`Invalid quantifier { min: ${quant.min}, max: ${quant.max} }`);
    }
    let value;
    if (quant.min === 0 && quant.max === 1) {
        value = "?";
    }
    else if (quant.min === 0 && quant.max === Infinity) {
        value = "*";
    }
    else if (quant.min === 1 && quant.max === Infinity) {
        value = "+";
    }
    else if (quant.min === quant.max) {
        value = `{${quant.min}}`;
    }
    else if (quant.max === Infinity) {
        value = `{${quant.min},}`;
    }
    else {
        value = `{${quant.min},${quant.max}}`;
    }
    if (!quant.greedy) {
        return value + "?";
    }
    else {
        return value;
    }
}
exports.quantToString = quantToString;
function quantAdd(quant, other) {
    var _a;
    if (typeof other === "number") {
        return {
            min: quant.min + other,
            max: quant.max + other,
            greedy: quant.greedy,
        };
    }
    else {
        if (quant.greedy === other.greedy || quant.greedy === undefined || other.greedy === undefined) {
            return {
                min: quant.min + other.min,
                max: quant.max + other.max,
                greedy: (_a = quant.greedy) !== null && _a !== void 0 ? _a : other.greedy,
            };
        }
        else {
            throw Error("The `greedy` property of the given quants is not compatible.");
        }
    }
}
exports.quantAdd = quantAdd;
function negateCharacterSetRaw(charSet) {
    let type = charSet.raw[1];
    if (type.toLowerCase() === type) {
        type = type.toUpperCase();
    }
    else {
        type = type.toLowerCase();
    }
    return `\\${type}${charSet.raw.substr(2)}`;
}
exports.negateCharacterSetRaw = negateCharacterSetRaw;
function elementsToCharacterClass(elements, negate = false) {
    let result = "";
    elements.forEach((e, i) => {
        switch (e.type) {
            case "Character":
                if (e.raw === "-") {
                    if (i === 0 || i === elements.length - 1) {
                        result += "-";
                    }
                    else {
                        result += "\\-";
                    }
                }
                else if (e.raw === "^") {
                    if (i === 0) {
                        result += "\\^";
                    }
                    else {
                        result += "^";
                    }
                }
                else if (e.raw === "]") {
                    result += "\\]";
                }
                else {
                    result += e.raw;
                }
                break;
            case "CharacterClassRange":
                if (e.min.raw === "^" && i === 0) {
                    result += "\\^-" + e.max.raw;
                }
                else {
                    result += e.min.raw + "-" + e.max.raw;
                }
                break;
            case "CharacterSet":
                result += e.raw;
                break;
            default:
                throw util_1.assertNever(e);
        }
    });
    return "[" + (negate ? "^" : "") + result + "]";
}
exports.elementsToCharacterClass = elementsToCharacterClass;
function isEmptyBackreference(backreference) {
    const group = backreference.resolved;
    if (hasSomeAncestor(backreference, a => a === group)) {
        return true;
    }
    if (isZeroLength(group)) {
        return true;
    }
    function findBackreference(node) {
        const parent = node.parent;
        switch (parent.type) {
            case "Alternative": {
                const index = parent.elements.indexOf(node);
                let next;
                if (matchingDirection(node) === "ltr") {
                    next = parent.elements.slice(index + 1);
                }
                else {
                    next = parent.elements.slice(0, index);
                }
                if (next.some(e => hasSomeDescendant(e, d => d === backreference))) {
                    return true;
                }
                const parentParent = parent.parent;
                if (parentParent.type === "Pattern") {
                    return false;
                }
                else {
                    return findBackreference(parentParent);
                }
            }
            case "Quantifier":
                return findBackreference(parent);
            default:
                throw new Error("What happened?");
        }
    }
    return !findBackreference(group);
}
exports.isEmptyBackreference = isEmptyBackreference;
function backreferenceAlwaysAfterGroup(backreference) {
    const group = backreference.resolved;
    if (hasSomeAncestor(backreference, a => a === group)) {
        return false;
    }
    function findBackreference(node) {
        const parent = node.parent;
        switch (parent.type) {
            case "Alternative": {
                const index = parent.elements.indexOf(node);
                let next;
                if (matchingDirection(node) === "ltr") {
                    next = parent.elements.slice(index + 1);
                }
                else {
                    next = parent.elements.slice(0, index);
                }
                if (next.some(e => hasSomeDescendant(e, d => d === backreference))) {
                    return true;
                }
                const parentParent = parent.parent;
                if (parentParent.type === "Pattern") {
                    return false;
                }
                else {
                    if (parentParent.alternatives.length > 1) {
                        return false;
                    }
                    return findBackreference(parentParent);
                }
            }
            case "Quantifier":
                if (parent.min === 0) {
                    return false;
                }
                return findBackreference(parent);
            default:
                throw new Error("What happened?");
        }
    }
    return findBackreference(group);
}
exports.backreferenceAlwaysAfterGroup = backreferenceAlwaysAfterGroup;
function getQuantifierRaw(quantifier) {
    return quantifier.raw.substr(quantifier.element.end - quantifier.start);
}
exports.getQuantifierRaw = getQuantifierRaw;
function matchingDirection(node) {
    let closestLookaround;
    hasSomeAncestor(node, a => {
        if (a.type === "Assertion") {
            closestLookaround = a;
            return true;
        }
        return false;
    });
    if (closestLookaround !== undefined && closestLookaround.kind === "lookbehind") {
        return "rtl";
    }
    return "ltr";
}
exports.matchingDirection = matchingDirection;
function invertMatchingDirection(direction) {
    return direction === "ltr" || direction === "lookahead" ? "rtl" : "ltr";
}
exports.invertMatchingDirection = invertMatchingDirection;
function assertionKindToMatchingDirection(kind) {
    return kind === "end" || kind === "lookahead" ? "ltr" : "rtl";
}
exports.assertionKindToMatchingDirection = assertionKindToMatchingDirection;
function hasAssertionWithDirection(element, direction) {
    return hasSomeDescendant(element, d => {
        if (d.type === "Assertion") {
            if (d.kind === "word") {
                return true;
            }
            if (isPotentiallyEmpty(element)) {
                return false;
            }
            if (direction === "lookahead" || direction === "ltr") {
                return d.kind === "lookahead" || d.kind === "end";
            }
            else {
                return d.kind === "lookbehind" || d.kind === "start";
            }
        }
        return false;
    });
}
exports.hasAssertionWithDirection = hasAssertionWithDirection;
function getLengthRange(element) {
    if (Array.isArray(element)) {
        let min = Infinity;
        let max = 0;
        for (const e of element) {
            const eRange = getLengthRange(e);
            if (eRange) {
                min = Math.min(min, eRange.min);
                max = Math.max(max, eRange.max);
            }
        }
        if (min > max) {
            return undefined;
        }
        else {
            return { min, max };
        }
    }
    switch (element.type) {
        case "Assertion":
            return { min: 0, max: 0 };
        case "Character":
        case "CharacterClass":
        case "CharacterSet":
            return { min: 1, max: 1 };
        case "Quantifier": {
            if (element.max === 0) {
                return { min: 0, max: 0 };
            }
            const elementRange = getLengthRange(element.element);
            if (!elementRange) {
                return element.min === 0 ? { min: 0, max: 0 } : undefined;
            }
            if (elementRange.max === 0) {
                return { min: 0, max: 0 };
            }
            elementRange.min *= element.min;
            elementRange.max *= element.max;
            return elementRange;
        }
        case "Alternative": {
            let min = 0;
            let max = 0;
            for (const e of element.elements) {
                const eRange = getLengthRange(e);
                if (!eRange) {
                    return undefined;
                }
                min += eRange.min;
                max += eRange.max;
            }
            return { min, max };
        }
        case "CapturingGroup":
        case "Group":
            return getLengthRange(element.alternatives);
        case "Backreference": {
            if (isEmptyBackreference(element)) {
                return { min: 0, max: 0 };
            }
            const resolvedRange = getLengthRange(element.resolved);
            if (!resolvedRange) {
                return backreferenceAlwaysAfterGroup(element) ? undefined : { min: 0, max: 0 };
            }
            if (resolvedRange.min > 0 && !backreferenceAlwaysAfterGroup(element)) {
                resolvedRange.min = 0;
            }
            return resolvedRange;
        }
        default:
            throw util_1.assertNever(element);
    }
}
exports.getLengthRange = getLengthRange;
function getFirstCharConsumedBy(element, direction, flags) {
    if (Array.isArray(element)) {
        return firstConsumedCharUnion(element.map(e => getFirstCharConsumedBy(e, direction, flags)), flags);
    }
    switch (element.type) {
        case "Assertion":
            switch (element.kind) {
                case "word":
                    return misdirectedAssertion();
                case "end":
                case "start":
                    if (assertionKindToMatchingDirection(element.kind) === direction) {
                        if (flags.multiline) {
                            return lineAssertion();
                        }
                        else {
                            return edgeAssertion();
                        }
                    }
                    else {
                        return misdirectedAssertion();
                    }
                case "lookahead":
                case "lookbehind":
                    if (assertionKindToMatchingDirection(element.kind) === direction) {
                        if (element.negate) {
                            if (hasSomeDescendant(element, d => d !== element && d.type === "Assertion")) {
                                return misdirectedAssertion();
                            }
                            const firstChar = getFirstCharConsumedBy(element.alternatives, direction, flags);
                            const range = getLengthRange(element.alternatives);
                            if (firstChar.empty || !range) {
                                return { char: char_util_1.emptyCharSet(flags), empty: false, exact: true };
                            }
                            if (!firstChar.exact || range.max !== 1) {
                                return misdirectedAssertion();
                            }
                            else {
                                return emptyWord({ char: firstChar.char.negate(), edge: true, exact: true });
                            }
                        }
                        else {
                            const firstChar = getFirstCharConsumedBy(element.alternatives, direction, flags);
                            return emptyWord(firstConsumedToLook(firstChar));
                        }
                    }
                    else {
                        return misdirectedAssertion();
                    }
                default:
                    throw util_1.assertNever(element);
            }
        case "Character":
        case "CharacterSet":
        case "CharacterClass":
            return { char: char_util_1.toCharSet(element, flags), empty: false, exact: true };
        case "Quantifier": {
            if (element.max === 0) {
                return emptyWord();
            }
            const firstChar = getFirstCharConsumedBy(element.element, direction, flags);
            if (element.min === 0) {
                return firstConsumedCharUnion([emptyWord(), firstChar], flags);
            }
            else {
                return firstChar;
            }
        }
        case "Alternative": {
            let elements = element.elements;
            if (direction === "rtl") {
                elements = [...elements];
                elements.reverse();
            }
            return firstConsumedCharConcat((function* () {
                for (const e of elements) {
                    yield getFirstCharConsumedBy(e, direction, flags);
                }
            })(), flags);
        }
        case "CapturingGroup":
        case "Group":
            return getFirstCharConsumedBy(element.alternatives, direction, flags);
        case "Backreference": {
            if (isEmptyBackreference(element)) {
                return emptyWord();
            }
            const resolvedChar = getFirstCharConsumedBy(element.resolved, direction, flags);
            resolvedChar.exact = resolvedChar.exact && resolvedChar.char.size <= 1;
            if (backreferenceAlwaysAfterGroup(element)) {
                return resolvedChar;
            }
            else {
                return firstConsumedCharUnion([resolvedChar, emptyWord()], flags);
            }
        }
        default:
            throw util_1.assertNever(element);
    }
    function misdirectedAssertion() {
        return emptyWord({
            char: char_util_1.allCharSet(flags),
            edge: true,
            exact: false,
        });
    }
    function edgeAssertion() {
        return emptyWord(firstLookCharEdgeAccepting(flags));
    }
    function lineAssertion() {
        return emptyWord({
            char: char_util_1.lineTerminatorCharSet(flags),
            edge: true,
            exact: true,
        });
    }
    function emptyWord(look) {
        return firstConsumedCharEmptyWord(flags, look);
    }
}
exports.getFirstCharConsumedBy = getFirstCharConsumedBy;
function firstLookCharTriviallyAccepting(flags) {
    return { char: char_util_1.allCharSet(flags), edge: true, exact: true };
}
function firstLookCharEdgeAccepting(flags) {
    return { char: char_util_1.emptyCharSet(flags), edge: true, exact: true };
}
function firstConsumedCharEmptyWord(flags, look) {
    return {
        char: char_util_1.emptyCharSet(flags),
        empty: true,
        exact: true,
        look: look !== null && look !== void 0 ? look : firstLookCharTriviallyAccepting(flags),
    };
}
class CharUnion {
    constructor(char) {
        this.char = char;
        this.exact = true;
    }
    add(char, exact) {
        if (this.exact && !exact && !this.char.isSupersetOf(char)) {
            this.exact = false;
        }
        else if (!this.exact && exact && char.isSupersetOf(this.char)) {
            this.exact = true;
        }
        this.char = this.char.union(char);
    }
    static emptyFromFlags(flags) {
        return new CharUnion(char_util_1.emptyCharSet(flags));
    }
    static emptyFromMaximum(maximum) {
        return new CharUnion(refa_1.CharSet.empty(maximum));
    }
}
function firstConsumedCharUnion(iter, flags) {
    const union = CharUnion.emptyFromFlags(flags);
    const looks = [];
    for (const itemChar of iter) {
        union.add(itemChar.char, itemChar.exact);
        if (itemChar.empty) {
            looks.push(itemChar.look);
        }
    }
    if (looks.length > 0) {
        const lookUnion = CharUnion.emptyFromFlags(flags);
        let edge = false;
        for (const look of looks) {
            lookUnion.add(look.char, look.exact);
            edge = edge || look.edge;
        }
        return {
            char: union.char,
            exact: union.exact,
            empty: true,
            look: { char: lookUnion.char, exact: lookUnion.exact, edge },
        };
    }
    else {
        return { char: union.char, exact: union.exact, empty: false };
    }
}
function firstConsumedCharConcat(iter, flags) {
    const union = CharUnion.emptyFromFlags(flags);
    let look = firstLookCharTriviallyAccepting(flags);
    for (const item of iter) {
        union.add(item.char.intersect(look.char), look.exact && item.exact);
        if (item.empty) {
            const charIntersection = look.char.intersect(item.look.char);
            look = {
                char: charIntersection,
                exact: (look.exact && item.look.exact) || charIntersection.isEmpty,
                edge: look.edge && item.look.edge,
            };
        }
        else {
            return { char: union.char, exact: union.exact, empty: false };
        }
    }
    return { char: union.char, exact: union.exact, empty: true, look };
}
function firstConsumedToLook(first) {
    if (first.empty) {
        const union = CharUnion.emptyFromMaximum(first.char.maximum);
        union.add(first.char, first.exact);
        union.add(first.look.char, first.look.exact);
        return {
            char: union.char,
            exact: union.exact,
            edge: first.look.edge,
        };
    }
    else {
        return {
            char: first.char,
            exact: first.exact,
            edge: false,
        };
    }
}
function followPaths(start, startMode, initialState, operations, direction) {
    function opEnter(element, state, direction) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        state = (_b = (_a = operations.enter) === null || _a === void 0 ? void 0 : _a.call(operations, element, state, direction)) !== null && _b !== void 0 ? _b : state;
        const continueInto = (_d = (_c = operations.continueInto) === null || _c === void 0 ? void 0 : _c.call(operations, element, state, direction)) !== null && _d !== void 0 ? _d : true;
        if (continueInto) {
            switch (element.type) {
                case "Assertion": {
                    if (element.kind === "lookahead" || element.kind === "lookbehind") {
                        const assertionDirection = assertionKindToMatchingDirection(element.kind);
                        const assertion = operations.join(element.alternatives.map(a => enterAlternative(a, operations.fork(state, direction), assertionDirection)), assertionDirection);
                        state = (_f = (_e = operations.endPath) === null || _e === void 0 ? void 0 : _e.call(operations, state, assertionDirection, "assertion")) !== null && _f !== void 0 ? _f : state;
                        state = (_h = (_g = operations.assert) === null || _g === void 0 ? void 0 : _g.call(operations, state, direction, assertion, assertionDirection)) !== null && _h !== void 0 ? _h : state;
                    }
                    break;
                }
                case "Group":
                case "CapturingGroup": {
                    state = operations.join(element.alternatives.map(a => enterAlternative(a, operations.fork(state, direction), direction)), direction);
                    break;
                }
                case "Quantifier": {
                    if (element.max === 0) {
                    }
                    else if (element.min === 0) {
                        state = operations.join([state, opEnter(element.element, operations.fork(state, direction), direction)], direction);
                    }
                    else {
                        state = opEnter(element.element, state, direction);
                    }
                    break;
                }
            }
        }
        state = (_k = (_j = operations.leave) === null || _j === void 0 ? void 0 : _j.call(operations, element, state, direction)) !== null && _k !== void 0 ? _k : state;
        return state;
    }
    function enterAlternative(alternative, state, direction) {
        var _a, _b;
        let i = direction === "ltr" ? 0 : alternative.elements.length - 1;
        const increment = direction === "ltr" ? +1 : -1;
        let element;
        for (; (element = alternative.elements[i]); i += increment) {
            state = opEnter(element, state, direction);
            const continueAfter = (_b = (_a = operations.continueAfter) === null || _a === void 0 ? void 0 : _a.call(operations, element, state, direction)) !== null && _b !== void 0 ? _b : true;
            if (!continueAfter) {
                break;
            }
        }
        return state;
    }
    function opNext(element, state, direction) {
        var _a, _b;
        function getNextElement(element) {
            var _a, _b;
            const parent = element.parent;
            if (parent.type === "CharacterClass" || parent.type === "CharacterClassRange") {
                throw new Error("The given element cannot be part of a character class.");
            }
            const continuePath = (_b = (_a = operations.continueAfter) === null || _a === void 0 ? void 0 : _a.call(operations, element, state, direction)) !== null && _b !== void 0 ? _b : true;
            if (!continuePath) {
                return false;
            }
            if (parent.type === "Quantifier") {
                if (parent.max <= 1) {
                    return getNextElement(parent);
                }
                else {
                    return [parent, getNextElement(parent)];
                }
            }
            else {
                const nextIndex = parent.elements.indexOf(element) + (direction === "ltr" ? +1 : -1);
                const nextElement = parent.elements[nextIndex];
                if (nextElement) {
                    return nextElement;
                }
                else {
                    const parentParent = parent.parent;
                    if (parentParent.type === "Pattern") {
                        return "pattern";
                    }
                    else if (parentParent.type === "Assertion") {
                        return "assertion";
                    }
                    else if (parentParent.type === "CapturingGroup" || parentParent.type === "Group") {
                        return getNextElement(parentParent);
                    }
                    throw util_1.assertNever(parentParent);
                }
            }
        }
        while (true) {
            let after = getNextElement(element);
            while (Array.isArray(after)) {
                const [quant, other] = after;
                state = operations.join([state, opEnter(quant, operations.fork(state, direction), direction)], direction);
                after = other;
            }
            if (after === false) {
                return state;
            }
            else if (after === "assertion" || after === "pattern") {
                state = (_b = (_a = operations.endPath) === null || _a === void 0 ? void 0 : _a.call(operations, state, direction, after)) !== null && _b !== void 0 ? _b : state;
                return state;
            }
            else {
                state = opEnter(after, state, direction);
                element = after;
            }
        }
    }
    if (!direction) {
        direction = matchingDirection(start);
    }
    if (startMode === "enter") {
        initialState = opEnter(start, initialState, direction);
    }
    return opNext(start, initialState, direction);
}
exports.followPaths = followPaths;
function getFirstConsumedCharAfter(afterThis, direction, flags) {
    const result = followPaths(afterThis, "next", { char: firstConsumedCharEmptyWord(flags), elements: [] }, {
        fork(state) {
            return state;
        },
        join(states) {
            const elements = new Set();
            states.forEach(s => s.elements.forEach(e => elements.add(e)));
            return {
                char: firstConsumedCharUnion(states.map(s => s.char), flags),
                elements: [...elements],
            };
        },
        enter(element, state, direction) {
            const first = getFirstCharConsumedBy(element, direction, flags);
            return {
                char: firstConsumedCharConcat([state.char, first], flags),
                elements: [...state.elements, element],
            };
        },
        continueInto() {
            return false;
        },
        continueAfter(_, state) {
            return state.char.empty;
        },
    }, direction);
    return { char: result.char, elements: result.elements };
}
exports.getFirstConsumedCharAfter = getFirstConsumedCharAfter;
function getFirstCharAfter(afterThis, direction, flags) {
    const result = getFirstConsumedCharAfter(afterThis, direction, flags);
    return { char: firstConsumedToLook(result.char), elements: [...result.elements] };
}
exports.getFirstCharAfter = getFirstCharAfter;
function getSingleConsumedChar(element, ignoreAssertions, flags) {
    if (Array.isArray(element)) {
        let empty = false;
        const union = CharUnion.emptyFromFlags(flags);
        for (const a of element) {
            const single = getSingleConsumedChar(a, ignoreAssertions, flags);
            empty = empty || single.empty;
            union.add(single.char, single.exact);
        }
        return { char: union.char, exact: union.exact, empty };
    }
    function multipleChars() {
        return { char: char_util_1.emptyCharSet(flags), exact: true, empty: false };
    }
    function zeroChars() {
        return { char: char_util_1.emptyCharSet(flags), exact: true, empty: true };
    }
    switch (element.type) {
        case "Alternative": {
            let nonEmptyResult = undefined;
            const emptyUnion = CharUnion.emptyFromFlags(flags);
            for (const e of element.elements) {
                const single = getSingleConsumedChar(e, ignoreAssertions, flags);
                if (nonEmptyResult === undefined) {
                    if (single.empty) {
                        emptyUnion.add(single.char, single.exact);
                    }
                    else {
                        nonEmptyResult = single;
                    }
                }
                else {
                    if (single.empty) {
                    }
                    else {
                        return multipleChars();
                    }
                }
            }
            if (nonEmptyResult) {
                return nonEmptyResult;
            }
            else {
                return { char: emptyUnion.char, exact: emptyUnion.exact, empty: true };
            }
        }
        case "Assertion": {
            return { char: char_util_1.emptyCharSet(flags), exact: false, empty: ignoreAssertions };
        }
        case "Character":
        case "CharacterClass":
        case "CharacterSet": {
            return { char: char_util_1.toCharSet(element, flags), exact: true, empty: false };
        }
        case "CapturingGroup":
        case "Group": {
            return getSingleConsumedChar(element.alternatives, ignoreAssertions, flags);
        }
        case "Backreference": {
            if (isEmptyBackreference(element)) {
                return zeroChars();
            }
            const resolvedSingle = getSingleConsumedChar(element.resolved, ignoreAssertions, flags);
            resolvedSingle.exact = resolvedSingle.exact && resolvedSingle.char.size <= 1;
            resolvedSingle.empty = resolvedSingle.empty || !backreferenceAlwaysAfterGroup(element);
            return resolvedSingle;
        }
        case "Quantifier": {
            if (element.max === 0) {
                return zeroChars();
            }
            const single = getSingleConsumedChar(element.element, ignoreAssertions, flags);
            if (!single.empty) {
                if (element.min === 0) {
                    single.empty = true;
                }
                else if (element.min >= 2) {
                    return multipleChars();
                }
            }
            return single;
        }
        default:
            throw util_1.assertNever(element);
    }
}
exports.getSingleConsumedChar = getSingleConsumedChar;
function effectiveQuantifierMax(node) {
    if (node == null) {
        return 1;
    }
    else {
        const parent = effectiveQuantifierMax(node.parent);
        if (node.type === "Quantifier") {
            if (node.max === 0 || parent === 0) {
                return 0;
            }
            else {
                return parent * node.max;
            }
        }
        else {
            return parent;
        }
    }
}
exports.effectiveQuantifierMax = effectiveQuantifierMax;
function underAStar(node) {
    return effectiveQuantifierMax(node) > 20;
}
exports.underAStar = underAStar;
function getParentPrefixAndSuffix(parent) {
    switch (parent.type) {
        case "Assertion":
            return ["(?" + (parent.kind === "lookahead" ? "" : "<") + (parent.negate ? "!" : "="), ")"];
        case "CapturingGroup":
            if (parent.name !== null) {
                return ["(?<" + parent.name + ">", ")"];
            }
            else {
                return ["(", ")"];
            }
        case "Group":
            return ["(?:", ")"];
        case "Pattern":
            return ["", ""];
        default:
            throw util_1.assertNever(parent);
    }
}
exports.getParentPrefixAndSuffix = getParentPrefixAndSuffix;
